【问题现象】
系统启动到初始化BOOT任务CORE STACK过程中打印堆栈地址时发生BUSFAULT。
【定位过程】
fa_vxnprintf函数打印指针时访问字符串数组charset取16进制数字时指针为0x004b5453("STK")，非stm32有效RAM或ROM地址。在 CORE_StackInit 函数中设置BOOT STACK Object Magic后ucharset全局指针值发变为 0x004b5453，但并非堆栈溢出，而是ucharset全局指针地址与BOOT STACK Object地址重叠，在初始化BOOT STACK时该指针被覆盖。
【问题原因】
1.ucharset 指针声明为 const char * ucharset 即 ucharset pointer to const char, 编译后 ucharset 为一个RAM变量，该指针指向16进制转化表，不可改变改指针的值，应当声明为 const char * const ucharset。
2.连接脚本中对RO DATA, RW DATA缺少描述导致段重叠。
【解决方案】
1.将ucharset/lcharset声明为数组(变更为  g_CharsetCapLetterTable和g_CharsetLowLetterTable )
STATIC CONST RO_USER_DATA STRING_CHAR_T g_CharsetLowLetterTable[] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 
    'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
};


STATIC CONST RO_USER_DATA STRING_CHAR_T g_CharsetCapLetterTable[] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 
    'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 
    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
};


2.修改连接脚本，加入对所有内存段的描述
; *************************************************************
; *** Scatter-Loading Description File generated by uVision ***
; *************************************************************

LR_IROM1 0x08000000 0x0000D000  {    ; load region size_region
  ER_IROM1 0x08000000 0x0000D000  {  ; load address = execution address
   *.o (RESET, +First)
   *(InRoot$$Sections)
   *.o (.CoreText, +RO)
   *.o (.UserText, +RO)
   *.o (.CoreROdata, +RO)
   *.o (.UserROdata, +RO)
   .ANY (+RO)
  }
  RW_IRAM1 0x20000000 0x00005000  {  ; RW data
   *.o (.UserRWdata, +RW +ZI)
   *.o (.CoreRWdata, +RW +ZI)
   .ANY (+RW +ZI)
   
  }
}

